deepdive {

  # Regularization
  sampler.sampler_args: "-l 700 -s 1 -i 500 --alpha 0.1 --diminish 0.99 --reg_param 2"

  db.default {
    driver   : "org.postgresql.Driver"
    url      : "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user     : ${PGUSER}
    password : ${PGPASSWORD}
    dbname   : ${DBNAME}
    host     : ${PGHOST}
    port     : ${PGPORT}
  }

  pipeline.pipelines.extractors_from_tutorial: [
    "ext_clear_table", "ext_process_dependencies", "ext_people", "ext_company", "ext_is_founder_candidates", "ext_is_founder_features", "foundersFactor"
  ]

  pipeline.pipelines.extractors_without_dependencies: [
    "ext_clear_table_without_dependencies", "ext_company", "ext_people", "ext_is_founder_candidates", "ext_filter_negative_examples", "ext_is_founder_features", "foundersFactor"
  ]

  pipeline.pipelines.features_and_inference: [
    "ext_is_founder_features", "foundersFactor"
  ]

  pipeline.pipelines.new_extractors: []
  pipeline.pipelines.dependencies: [
    "ext_clear_table",
    "ext_process_dependencies"
  ]

  #Change the pipleline here to leave out some extractors
  pipeline.run: "features_and_inference"

  # Put your variables here
  schema.variables {
    is_founder.is_true: Boolean
  }

  # Put your extractors here
  extraction.extractors {

  # Extractor 1: Clean output tables of all extractors
    ext_clear_table {
      style: "sql_extractor"
      sql: """
        DELETE FROM people_mentions;
        DELETE FROM company_mentions;
        DELETE FROM is_founder;
        DELETE FROM is_founder_features;
        DELETE FROM sentences_processed;
        """
    }

    ext_clear_table_without_dependencies {
      style: "sql_extractor"
      sql: """
        DELETE FROM people_mentions;
        DELETE FROM company_mentions;
        DELETE FROM is_founder;
        DELETE FROM is_founder_features;
        """
    }
    ext_filter_negative_examples {
      style: "sql_extractor"
      sql: """
        DROP TABLE IF EXISTS is_founder_sampled;
        CREATE TABLE is_founder_sampled AS SELECT * FROM is_founder
        WHERE is_true = 'f' ORDER BY random() LIMIT 2000;
        INSERT INTO is_founder_sampled SELECT * FROM is_founder WHERE is_true = 't';
        INSERT INTO is_founder_sampled SELECT * FROM is_founder WHERE is_true IS NULL;
        DELETE FROM is_founder;
        INSERT INTO is_founder SELECT * FROM is_founder_sampled;
      """
      dependencies: ["ext_is_founder_candidates"]
    }

    ext_process_dependencies {
      style: "json_extractor"
      input: """
                SELECT document_id,
                       sentence,
                       words,
                       lemma,
                       pos_tags,
                       dependency_labels,
                       dependency_parents,
                       ner_tags,
                       sentence_offset,
                       sentence_id
                FROM sentences"""
      output_relation: "sentences_processed"
      udf: ${APP_HOME}"/udf/ext_dependencies.py"
      dependencies: ["ext_clear_table"]
    }

    # Extractor 2: extract people mentions:
    ext_people {
      # The style of the extractor
      style: "tsv_extractor"
      # An input to the extractor is a row (tuple) of the following query:
      input: """
        SELECT  sentence_id,
                array_to_string(words, '~^~'),
                array_to_string(ner_tags, '~^~')
          FROM  sentences_processed"""

      # output of extractor will be written to this table:
      output_relation: "people_mentions"

      # This user-defined function will be performed on each row (tuple) of input query:
      udf: ${APP_HOME}"/udf/ext_people.py"

      dependencies: ["ext_clear_table", "ext_process_dependencies", "ext_clear_table_without_dependencies"]
    }

    # Extractor 2bis: extract companies mentions:
    ext_company {
      # The style of the extractor
      style: "tsv_extractor"
      # An input to the extractor is a row (tuple) of the following query:
      input: """
        SELECT  sentence_id,
                array_to_string(words, '~^~'),
                array_to_string(ner_tags, '~^~')
          FROM  sentences_processed"""

      # output of extractor will be written to this table:
      output_relation: "company_mentions"

      # This user-defined function will be performed on each row (tuple) of input query:
      udf: ${APP_HOME}"/udf/ext_company.py"

      dependencies: ["ext_clear_table", "ext_process_dependencies", "ext_clear_table_without_dependencies"]
    }


    # Extractor 3: extract mention relation candidates
    ext_is_founder_candidates {
      # The style of the extractor
      style: tsv_extractor
      # Each input (p1, p2) is a pair of mentions
      input: """
        SELECT  sentences_processed.sentence_id,
                p1.mention_id AS p1_mention_id,
                p1.text       AS p1_text,
                p2.mention_id AS p2_mention_id,
                p2.text       AS p2_text
         FROM   people_mentions p1,
                company_mentions p2,
                sentences_processed
        WHERE   p1.sentence_id = p2.sentence_id
          AND   p1.sentence_id = sentences_processed.sentence_id
          """
      output_relation : "is_founder"
      udf             : ${APP_HOME}"/udf/ext_is_founder_new.py"

      # Run this extractor after "ext_people" and "ext_company"
      dependencies    : ["ext_people", "ext_company"]
    }

    # Extractor 4: extract features for relation candidates
    ext_is_founder_features {
      style: "tsv_extractor"
      input: """
            SELECT  array_to_string(words, '~^~'),
                    array_to_string(lemma, '~^~'),
                    array_to_string(pos_tags, '~^~'),
                    array_to_string(dependencies, '~^~'),
                    array_to_string(ner_tags, '~^~'),
                    is_founder.relation_id,
                    p.start_position,
                    p.length,
                    c.start_position,
                    c.length
            FROM    is_founder,
                    people_mentions p,
                    company_mentions c,
                    sentences_processed
            WHERE   is_founder.person_id = p.mention_id
              AND   is_founder.company_id = c.mention_id
              AND   is_founder.sentence_id = sentences_processed.sentence_id;
           """
      output_relation : "is_founder_features"
      udf             : ${APP_HOME}"/udf/ext_is_founder_features.py"
      dependencies    : ["ext_is_founder_candidates", "ext_filter_negative_examples"]
      parallelism: 4
    }
  }

  # Put your inference rules here
  inference.factors {
    foundersFactor{
      input_query: """
        SELECT is_founder.id AS "is_founder.id",
               is_founder.is_true AS "is_founder.is_true",
               feature
        FROM is_founder,
             is_founder_features
        WHERE is_founder.relation_id = is_founder_features.relation_id
        """
      function : "IsTrue(is_founder.is_true)"
      weight : "?(feature)"
    }
  }
  # Specify a holdout fraction
  calibration.holdout_fraction: 0.25

}
