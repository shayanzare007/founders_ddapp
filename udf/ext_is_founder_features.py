#! /usr/bin/env python

import sys, os
import ddlib     # DeepDive python utility
from itertools import combinations

ARR_DELIM = '~^~'
WORDS_BETWEEN_THRESHOLD = 20
ORGANIZATIONS_BETWEEN_THRESHOLD = 1


BASE_DIR = os.path.dirname(os.path.realpath(__file__))
stop_words_fp = open(BASE_DIR + '/../udf/dicts/stop_words.txt')
stop_words = set()
for line in stop_words_fp:
    stop_words.add(line.strip())

punctuation_fp = open(BASE_DIR + '/../udf/dicts/punctuation.txt')
punctuation = set()
for line in punctuation_fp:
    punctuation.add(line.strip())


ddlib.load_dictionary(BASE_DIR + "/dicts/founder.txt", dict_id="founder")
ddlib.load_dictionary(BASE_DIR + "/dicts/non_founder.txt", dict_id="non_founder")
ddlib.load_dictionary(BASE_DIR + "/dicts/founder_verbs.txt", dict_id="founder_verbs")
ddlib.load_dictionary(BASE_DIR + "/dicts/non_founder_verbs.txt", dict_id="non_founder_verbs")

killer_depfeats = set(['INV_BETW_L_[conj_and agent nsubjpass]',
                   'INV_BETW_L_[agent nsubjpass]',
                   'BETW_L_[poss appos]',
                   'INV_BETW_L_[conj_and agent vmod nsubj nn]',
                   'BETW_L_[conj_and nsubj dobj]',
                   'BETW_[poss]',
                   'BETW_L_[poss]',
                   'BETW_D_[poss]',
                   'BETW_[appos founder prep_of]',
                   'BETW_[appos co-founder prep_of]',
                   'KW_L_[appos]_[prep_of]',
                   'KW_[appos]_[prep_of]'])

downer_depfeats = set(['INV_BETW_L_[dobj nsubj]',
                   'INV_BETW_L_[conj_and conj_and]',
                   'BETW_L_[nsubjpass agent]',
                   'INV_BETW_L_[appos appos]'])

# For each input tuple
for row in sys.stdin:
    parts = row.strip().split('\t')

    # Get all fields from a row
    words = parts[0].split(ARR_DELIM)
    lemmas = parts[1].split(ARR_DELIM)
    poses = parts[2].split(ARR_DELIM)
    dependencies = parts[3].split(ARR_DELIM)
    ners = parts[4].split(ARR_DELIM)
    relation_id = parts[5]
    p_start, p_length, c_start, c_length = [int(x) for x in parts[6:]]

  # Skip lines with empty dependency paths
    if len(dependencies) == 0:
        print >>sys.stderr, str(relation_id) + '\t' + 'DEP_PATH_EMPTY'
        continue

  # Get a sentence from ddlib -- array of "Word" objects
    try:
        sentence = ddlib.get_sentence(
            [0, ] * len(words),  [0, ] * len(words), words, lemmas, poses,
            dependencies, ners)
    except:
        print >>sys.stderr, dependencies
        continue

    # Create two spans of person mentions
    span1 = ddlib.Span(begin_word_id=p_start, length=p_length)
    span2 = ddlib.Span(begin_word_id=c_start, length=c_length)

    # Features for this pair come in here
    features = set()

    words_between = ddlib.tokens_between_spans(words, span1, span2)
    if len(words_between.elements) > WORDS_BETWEEN_THRESHOLD:
        features.add("num_words_between>{0}".format(WORDS_BETWEEN_THRESHOLD))

    # Get generic features generated by ddlib
    for feature in ddlib.get_generic_features_relation(sentence, span1, span2):
        if feature in killer_depfeats:
            features.add('killer')
        elif feature in downer_depfeats:
            features.add('downer')

        if feature.startswith('NER_SEQ'):
            parts = feature[feature.find('[')+1: feature.find(']')].split(' ')
            orgs_between = sum(part == 'ORGANIZATION' for part in parts)
            if orgs_between >= ORGANIZATIONS_BETWEEN_THRESHOLD:
                features.add('organizations_between>={0}'.format(ORGANIZATIONS_BETWEEN_THRESHOLD))
        if 'POS_SEQ' in feature or 'KW' in feature or 'NGRAM' in feature:
            parts = feature[feature.find('[')+1: feature.rfind(']')].split(' ')
            reject = False
            for part in parts:
                if part == '':
                    continue
                if part in punctuation or part[0].isupper() or part in stop_words:
                    reject = True
                    break
            if reject == False and len(parts) == 1 and parts[0] in stop_words:
                reject = True
            if not reject:
                features.add(feature)


    pairs = set()
    # for pair in combinations(features, 2):
    #     pairs.add(','.join(sorted(pair)))

    for feature in features.union(pairs):
        print str(relation_id) + '\t' + feature
